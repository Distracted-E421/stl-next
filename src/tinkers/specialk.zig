const std = @import("std");
const interface = @import("interface.zig");
const Tinker = interface.Tinker;
const Context = interface.Context;
const EnvMap = interface.EnvMap;
const ArgList = interface.ArgList;
const Priority = interface.Priority;
const config = @import("../core/config.zig");

// ═══════════════════════════════════════════════════════════════════════════════
// SPECIALK TINKER
// ═══════════════════════════════════════════════════════════════════════════════
//
// Special K is a powerful game modification tool providing:
//   - HDR injection and tonemapping
//   - Frame rate limiting with low latency
//   - Texture modding support
//   - Input latency reduction
//
// On Linux (via Wine/Proton), it requires DLL injection into the Wine prefix.
//
// ═══════════════════════════════════════════════════════════════════════════════

pub const SpecialkFeature = enum {
    hdr, // HDR injection
    framerate_limit, // Low-latency frame capping
    texture_mod, // Texture modding support
    input_fix, // Input latency fixes
    overlay_fix, // Steam overlay compatibility
    vsync_fix, // VSync and tearing control
};

/// Get SpecialK installation directory
fn getInstallDir(allocator: std.mem.Allocator) ![]const u8 {
    const home = std.posix.getenv("HOME") orelse "/tmp";
    return std.fmt.allocPrint(allocator, "{s}/.local/share/stl-next/specialk", .{home});
}

/// Get game-specific config directory
fn getGameConfigDir(allocator: std.mem.Allocator, app_id: u32) ![]const u8 {
    const home = std.posix.getenv("HOME") orelse "/tmp";
    return std.fmt.allocPrint(allocator, "{s}/.config/stl-next/specialk/{d}", .{ home, app_id });
}

/// Generate SpecialK.ini content
fn generateConfig(allocator: std.mem.Allocator, sk_config: config.SpecialkConfig) ![]const u8 {
    // Use bufPrint approach for simplicity in Zig 0.15.x
    var buf: [4096]u8 = undefined;
    var pos: usize = 0;

    // Header
    pos += (try std.fmt.bufPrint(buf[pos..], "; SpecialK configuration generated by STL-Next\n\n", .{})).len;

    // Global section
    pos += (try std.fmt.bufPrint(buf[pos..], "[SpecialK.Global]\n", .{})).len;
    pos += (try std.fmt.bufPrint(buf[pos..], "LowLatencyMode={s}\n", .{if (sk_config.low_latency) "true" else "false"})).len;
    pos += (try std.fmt.bufPrint(buf[pos..], "InjectionDelay={d}\n\n", .{sk_config.injection_delay_ms})).len;

    // Frame rate section
    if (sk_config.target_fps) |fps| {
        pos += (try std.fmt.bufPrint(buf[pos..], "[SpecialK.Framerate]\n", .{})).len;
        pos += (try std.fmt.bufPrint(buf[pos..], "TargetFPS={d}\n", .{fps})).len;
        pos += (try std.fmt.bufPrint(buf[pos..], "FlipModel={s}\n", .{if (sk_config.flip_model) "true" else "false"})).len;
        pos += (try std.fmt.bufPrint(buf[pos..], "WaitForVBLANK=false\n\n", .{})).len;
    }

    // HDR section
    for (sk_config.features) |feature| {
        if (feature == .hdr) {
            pos += (try std.fmt.bufPrint(buf[pos..], "[SpecialK.HDR]\n", .{})).len;
            pos += (try std.fmt.bufPrint(buf[pos..], "Enable=true\n", .{})).len;
            pos += (try std.fmt.bufPrint(buf[pos..], "PaperWhite={d:.1}\n", .{sk_config.hdr_brightness * 80.0})).len;
            pos += (try std.fmt.bufPrint(buf[pos..], "PeakBrightness={d:.1}\n", .{sk_config.hdr_peak})).len;
            pos += (try std.fmt.bufPrint(buf[pos..], "ToneMapping=ReinHard\n\n", .{})).len;
            break;
        }
    }

    // Texture section
    if (sk_config.texture_cache) {
        pos += (try std.fmt.bufPrint(buf[pos..], "[SpecialK.Textures]\n", .{})).len;
        pos += (try std.fmt.bufPrint(buf[pos..], "Enable=true\nCache=true\nDump=false\n\n", .{})).len;
    }

    // Input section
    for (sk_config.features) |feature| {
        if (feature == .input_fix) {
            pos += (try std.fmt.bufPrint(buf[pos..], "[SpecialK.Input]\n", .{})).len;
            pos += (try std.fmt.bufPrint(buf[pos..], "BlockRawInput=false\nReduceLatency=true\n\n", .{})).len;
            break;
        }
    }

    return allocator.dupe(u8, buf[0..pos]);
}

fn isEnabled(ctx: *const Context) bool {
    return ctx.game_config.specialk.enabled;
}

fn preparePrefix(ctx: *const Context) anyerror!void {
    if (!isEnabled(ctx)) return;

    std.log.info("SpecialK: Preparing injection for game {d}", .{ctx.app_id});

    // Check if SpecialK is installed
    const install_dir = try getInstallDir(ctx.allocator);
    defer ctx.allocator.free(install_dir);

    const sk_dll = try std.fmt.allocPrint(ctx.allocator, "{s}/SpecialK64.dll", .{install_dir});
    defer ctx.allocator.free(sk_dll);

    std.fs.accessAbsolute(sk_dll, .{}) catch {
        std.log.warn("SpecialK: Not installed at {s}", .{install_dir});
        std.log.warn("SpecialK: Download from https://special-k.info/", .{});
        return;
    };

    std.log.info("SpecialK: Found installation at {s}", .{install_dir});
}

fn modifyEnv(ctx: *const Context, env: *EnvMap) anyerror!void {
    if (!isEnabled(ctx)) return;

    const app_id = ctx.app_id;

    // Create game-specific config
    const config_dir = try getGameConfigDir(ctx.allocator, app_id);
    defer ctx.allocator.free(config_dir);

    std.fs.makeDirAbsolute(config_dir) catch |err| {
        if (err != error.PathAlreadyExists) return err;
    };

    // Generate config
    const config_content = try generateConfig(ctx.allocator, ctx.game_config.specialk);
    defer ctx.allocator.free(config_content);

    const config_path = try std.fmt.allocPrint(ctx.allocator, "{s}/SpecialK.ini", .{config_dir});
    defer ctx.allocator.free(config_path);

    const file = try std.fs.createFileAbsolute(config_path, .{});
    defer file.close();
    try file.writeAll(config_content);

    // Set environment for Wine/Proton DLL override
    const install_dir = try getInstallDir(ctx.allocator);
    defer ctx.allocator.free(install_dir);

    // WINEDLLPATH approach for Proton
    if (std.posix.getenv("WINEDLLPATH")) |existing| {
        const new_path = try std.fmt.allocPrint(ctx.allocator, "{s};{s}", .{ existing, install_dir });
        try env.put("WINEDLLPATH", new_path);
    } else {
        try env.put("WINEDLLPATH", install_dir);
    }

    // DLL override for SpecialK injection
    if (std.posix.getenv("WINEDLLOVERRIDES")) |existing| {
        const new_overrides = try std.fmt.allocPrint(
            ctx.allocator,
            "{s};dxgi=n,b",
            .{existing},
        );
        try env.put("WINEDLLOVERRIDES", new_overrides);
    } else {
        try env.put("WINEDLLOVERRIDES", "dxgi=n,b");
    }

    std.log.info("SpecialK: Configuration written to {s}", .{config_path});

    // Log enabled features
    std.log.info("SpecialK: Enabled features:", .{});
    for (ctx.game_config.specialk.features) |feature| {
        std.log.info("  - {s}", .{@tagName(feature)});
    }
    if (ctx.game_config.specialk.target_fps) |fps| {
        std.log.info("  - Frame limit: {d} FPS", .{fps});
    }
}

fn modifyArgs(ctx: *const Context, args: *ArgList) anyerror!void {
    _ = ctx;
    _ = args;
    // SpecialK doesn't modify command line arguments
}

fn cleanup(ctx: *const Context) void {
    _ = ctx;
    std.log.debug("SpecialK: Cleanup (no-op)", .{});
}

pub const specialk_tinker = Tinker{
    .id = "specialk",
    .name = "SpecialK",
    .priority = Priority.OVERLAY,
    .isEnabledFn = isEnabled,
    .preparePrefixFn = preparePrefix,
    .modifyEnvFn = modifyEnv,
    .modifyArgsFn = modifyArgs,
    .cleanupFn = cleanup,
};

// ═══════════════════════════════════════════════════════════════════════════════
// CLI COMMANDS
// ═══════════════════════════════════════════════════════════════════════════════

pub fn showInfo() void {
    const compat = @import("../compat.zig");

    compat.print(
        \\Special K Integration
        \\━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        \\
        \\Special K is a powerful game modification framework providing:
        \\
        \\  HDR Injection     - Add HDR to SDR games
        \\  Frame Pacing      - Low-latency frame limiting
        \\  Texture Modding   - Load custom textures
        \\  Input Fixes       - Reduce input latency
        \\
        \\Installation:
        \\  1. Download from https://special-k.info/
        \\  2. Extract SpecialK64.dll to ~/.local/share/stl-next/specialk/
        \\  3. Enable in game config: "specialk": {{ "enabled": true }}
        \\
        \\━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        \\
    , .{});
}
