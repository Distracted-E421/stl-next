const std = @import("std");
const interface = @import("interface.zig");
const Tinker = interface.Tinker;
const Context = interface.Context;
const EnvMap = interface.EnvMap;
const ArgList = interface.ArgList;
const Priority = interface.Priority;
const config = @import("../core/config.zig");

// ═══════════════════════════════════════════════════════════════════════════════
// VKBASALT TINKER
// ═══════════════════════════════════════════════════════════════════════════════
//
// vkBasalt is a Vulkan post-processing layer providing:
//   - Contrast Adaptive Sharpening (CAS)
//   - Fast Approximate Anti-Aliasing (FXAA)
//   - Subpixel Morphological Anti-Aliasing (SMAA)
//   - Deband
//   - Custom ReShade-style effects
//
// ═══════════════════════════════════════════════════════════════════════════════

// Re-export from config for convenience
pub const VkbasaltEffect = config.VkbasaltEffect;

/// Get config directory
fn getConfigDir(allocator: std.mem.Allocator) ![]const u8 {
    const home = std.posix.getenv("HOME") orelse "/tmp";
    return std.fmt.allocPrint(allocator, "{s}/.config/vkBasalt", .{home});
}

/// Generate vkBasalt.conf content
fn generateConfig(allocator: std.mem.Allocator, vkbasalt_config: config.VkbasaltConfig) ![]const u8 {
    // Use bufPrint approach for simplicity in Zig 0.15.x
    var buf: [4096]u8 = undefined;
    var pos: usize = 0;

    // Header
    pos += (try std.fmt.bufPrint(buf[pos..], "# vkBasalt configuration generated by STL-Next\n\n", .{})).len;

    // Effects list
    pos += (try std.fmt.bufPrint(buf[pos..], "effects = ", .{})).len;
    for (vkbasalt_config.effects, 0..) |effect, i| {
        if (i > 0) pos += (try std.fmt.bufPrint(buf[pos..], ":", .{})).len;
        pos += (try std.fmt.bufPrint(buf[pos..], "{s}", .{effect.toString()})).len;
    }
    for (vkbasalt_config.custom_effects) |custom| {
        pos += (try std.fmt.bufPrint(buf[pos..], ":{s}", .{custom})).len;
    }
    pos += (try std.fmt.bufPrint(buf[pos..], "\n\n", .{})).len;

    // CAS settings
    pos += (try std.fmt.bufPrint(buf[pos..], "casSharpness = {d:.2}\n", .{vkbasalt_config.cas_sharpness})).len;

    // FXAA settings
    pos += (try std.fmt.bufPrint(buf[pos..], "fxaaQualitySubpix = {d:.2}\n", .{@as(f32, @floatFromInt(vkbasalt_config.fxaa_quality)) * 0.2})).len;
    pos += (try std.fmt.bufPrint(buf[pos..], "fxaaQualityEdgeThreshold = 0.125\n", .{})).len;
    pos += (try std.fmt.bufPrint(buf[pos..], "fxaaQualityEdgeThresholdMin = 0.0312\n", .{})).len;

    // SMAA settings
    pos += (try std.fmt.bufPrint(buf[pos..], "smaaEdgeDetection = luma\n", .{})).len;
    pos += (try std.fmt.bufPrint(buf[pos..], "smaaThreshold = {d:.3}\n", .{vkbasalt_config.smaa_threshold})).len;

    // Deband settings
    pos += (try std.fmt.bufPrint(buf[pos..], "debandRange = {d}\n", .{vkbasalt_config.deband_range})).len;

    // LUT settings
    if (vkbasalt_config.lut_file) |lut| {
        pos += (try std.fmt.bufPrint(buf[pos..], "lutFile = {s}\n", .{lut})).len;
    }

    // Toggle key
    if (vkbasalt_config.toggle_key) |key| {
        pos += (try std.fmt.bufPrint(buf[pos..], "toggleKey = {s}\n", .{key})).len;
    }

    return allocator.dupe(u8, buf[0..pos]);
}

fn isEnabled(ctx: *const Context) bool {
    return ctx.game_config.vkbasalt.enabled;
}

fn preparePrefix(ctx: *const Context) anyerror!void {
    if (!isEnabled(ctx)) return;

    std.log.info("vkBasalt: Preparing Vulkan post-processing", .{});

    // Check if vkbasalt layer is installed
    const layer_paths = [_][]const u8{
        "/usr/share/vulkan/implicit_layer.d/vkBasalt.json",
        "/usr/local/share/vulkan/implicit_layer.d/vkBasalt.json",
    };

    var found = false;
    for (layer_paths) |path| {
        std.fs.accessAbsolute(path, .{}) catch continue;
        std.log.info("vkBasalt: Found layer at {s}", .{path});
        found = true;
        break;
    }

    if (!found) {
        std.log.warn("vkBasalt: Not installed!", .{});
        std.log.warn("vkBasalt: Install via: nix-shell -p vkBasalt", .{});
    }
}

fn modifyEnv(ctx: *const Context, env: *EnvMap) anyerror!void {
    if (!isEnabled(ctx)) return;

    // Enable vkBasalt layer
    try env.put("ENABLE_VKBASALT", "1");

    // Generate and write config
    const config_dir = try getConfigDir(ctx.allocator);
    defer ctx.allocator.free(config_dir);

    // Create config directory if needed
    std.fs.makeDirAbsolute(config_dir) catch |err| {
        if (err != error.PathAlreadyExists) return err;
    };

    // Generate config content
    const config_content = try generateConfig(ctx.allocator, ctx.game_config.vkbasalt);
    defer ctx.allocator.free(config_content);

    // Write config file
    const config_path = try std.fmt.allocPrint(ctx.allocator, "{s}/vkBasalt.conf", .{config_dir});
    defer ctx.allocator.free(config_path);

    const file = try std.fs.createFileAbsolute(config_path, .{});
    defer file.close();
    try file.writeAll(config_content);

    // Set config path
    try env.put("VKBASALT_CONFIG_FILE", config_path);

    // Log effects
    std.log.info("vkBasalt: Enabled effects:", .{});
    for (ctx.game_config.vkbasalt.effects) |effect| {
        std.log.info("  - {s}", .{effect.toString()});
    }

    std.log.info("vkBasalt: Configuration written to {s}", .{config_path});
}

fn modifyArgs(ctx: *const Context, args: *ArgList) anyerror!void {
    _ = ctx;
    _ = args;
    // vkBasalt doesn't modify command line arguments
}

fn cleanup(ctx: *const Context) void {
    _ = ctx;
    std.log.debug("vkBasalt: Cleanup (no-op)", .{});
}

pub const vkbasalt_tinker = Tinker{
    .id = "vkbasalt",
    .name = "vkBasalt",
    .priority = Priority.OVERLAY,
    .isEnabledFn = isEnabled,
    .preparePrefixFn = preparePrefix,
    .modifyEnvFn = modifyEnv,
    .modifyArgsFn = modifyArgs,
    .cleanupFn = cleanup,
};

// ═══════════════════════════════════════════════════════════════════════════════
// CLI COMMANDS
// ═══════════════════════════════════════════════════════════════════════════════

pub fn showPresets() void {
    const compat = @import("../compat.zig");

    compat.print(
        \\vkBasalt Presets
        \\━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        \\
        \\Sharpening Only (Recommended):
        \\  effects = cas
        \\  casSharpness = 0.4
        \\
        \\Anti-Aliasing:
        \\  effects = fxaa
        \\  fxaaQualitySubpix = 0.75
        \\
        \\Quality AA (Performance Hit):
        \\  effects = smaa
        \\  smaaEdgeDetection = luma
        \\
        \\Full Pipeline:
        \\  effects = smaa:cas:deband
        \\
        \\━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        \\
    , .{});
}
