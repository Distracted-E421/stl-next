const std = @import("std");

// ═══════════════════════════════════════════════════════════════════════════════
// CONFIG: STL-Next Configuration System
// ═══════════════════════════════════════════════════════════════════════════════
//
// Manages per-game and global configuration for STL-Next.
// Config files are JSON for easy editing and structured shell integration.
//
// Paths:
// - Global: $XDG_CONFIG_HOME/stl-next/config.json
// - Per-game: $XDG_CONFIG_HOME/stl-next/games/<AppID>.json
//
// ═══════════════════════════════════════════════════════════════════════════════

pub const GameConfig = struct {
    app_id: u32,

    // ─── Proton/Wine Settings ───────────────────────────────────────────────────
    proton_version: ?[]const u8 = null, // e.g., "GE-Proton8-25"
    wine_prefix: ?[]const u8 = null, // Custom prefix path
    use_native: bool = false, // Force native Linux binary

    // ─── Overlay Settings ───────────────────────────────────────────────────────
    mangohud: MangohudConfig = .{},
    gamescope: GamescopeConfig = .{},
    gamemode: bool = true,

    // ─── Visual Enhancements ────────────────────────────────────────────────────
    reshade: ReshadeConfig = .{},
    vkbasalt: VkbasaltConfig = .{},

    // ─── Mod Manager Integration ────────────────────────────────────────────────
    mod_organizer: ?ModOrganizerConfig = null,
    vortex: ?VortexConfig = null,

    // ─── VR Settings ────────────────────────────────────────────────────────────
    vr: VrConfig = .{},

    // ─── Launch Behavior ────────────────────────────────────────────────────────
    wait_for_requester: bool = true, // Show pre-launch UI
    wait_timeout_seconds: u32 = 10,
    custom_launch_args: []const u8 = "",
    custom_env_vars: []const EnvVar = &.{},

    pub fn defaults(app_id: u32) GameConfig {
        return .{ .app_id = app_id };
    }
};

pub const EnvVar = struct {
    key: []const u8,
    value: []const u8,
};

// ─── MangoHud Configuration ─────────────────────────────────────────────────────
pub const MangohudConfig = struct {
    enabled: bool = false,
    show_fps: bool = true,
    show_frametime: bool = true,
    show_cpu: bool = true,
    show_gpu: bool = true,
    show_ram: bool = false,
    show_vram: bool = true,
    show_battery: bool = false,
    position: Position = .top_left,
    font_size: u8 = 24,
    custom_config: ?[]const u8 = null, // Path to custom config

    pub const Position = enum {
        top_left,
        top_right,
        bottom_left,
        bottom_right,
    };

    /// Generate MangoHud config file content
    pub fn generateConfig(self: *const MangohudConfig, allocator: std.mem.Allocator) ![]const u8 {
        var buf = std.ArrayList(u8).init(allocator);
        const writer = buf.writer();

        try writer.writeAll("# Generated by STL-Next\n");

        if (self.show_fps) try writer.writeAll("fps\n");
        if (self.show_frametime) try writer.writeAll("frametime\n");
        if (self.show_cpu) try writer.writeAll("cpu_stats\ncpu_temp\n");
        if (self.show_gpu) try writer.writeAll("gpu_stats\ngpu_temp\n");
        if (self.show_ram) try writer.writeAll("ram\n");
        if (self.show_vram) try writer.writeAll("vram\n");
        if (self.show_battery) try writer.writeAll("battery\n");

        try writer.print("font_size={d}\n", .{self.font_size});

        const pos_str = switch (self.position) {
            .top_left => "top-left",
            .top_right => "top-right",
            .bottom_left => "bottom-left",
            .bottom_right => "bottom-right",
        };
        try writer.print("position={s}\n", .{pos_str});

        return buf.toOwnedSlice();
    }
};

// ─── Gamescope Configuration ────────────────────────────────────────────────────
pub const GamescopeConfig = struct {
    enabled: bool = false,
    width: ?u32 = null, // Output width (-w)
    height: ?u32 = null, // Output height (-h)
    internal_width: ?u32 = null, // Render width (-W)
    internal_height: ?u32 = null, // Render height (-H)
    fullscreen: bool = true,
    borderless: bool = false,
    fsr: bool = false, // AMD FidelityFX Super Resolution
    fsr_sharpness: u8 = 5, // 0-20
    fps_limit: ?u32 = null,
    vrr: bool = false, // Variable Refresh Rate

    /// Build gamescope command arguments
    pub fn buildArgs(self: *const GamescopeConfig, allocator: std.mem.Allocator) ![]const []const u8 {
        var args = std.ArrayList([]const u8).init(allocator);

        try args.append("gamescope");

        if (self.width) |w| {
            try args.append("-w");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{w}));
        }
        if (self.height) |h| {
            try args.append("-h");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{h}));
        }
        if (self.internal_width) |w| {
            try args.append("-W");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{w}));
        }
        if (self.internal_height) |h| {
            try args.append("-H");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{h}));
        }

        if (self.fullscreen) try args.append("-f");
        if (self.borderless) try args.append("-b");

        if (self.fsr) {
            try args.append("-F");
            try args.append("fsr");
            try args.append("--sharpness");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{self.fsr_sharpness}));
        }

        if (self.fps_limit) |fps| {
            try args.append("-r");
            try args.append(try std.fmt.allocPrint(allocator, "{d}", .{fps}));
        }

        if (self.vrr) try args.append("--adaptive-sync");

        try args.append("--");

        return args.toOwnedSlice();
    }
};

// ─── ReShade Configuration ──────────────────────────────────────────────────────
pub const ReshadeConfig = struct {
    enabled: bool = false,
    version: ?[]const u8 = null, // Specific version
    preset: ?[]const u8 = null, // Path to preset file
    auto_update: bool = false,
};

// ─── vkBasalt Configuration ─────────────────────────────────────────────────────
pub const VkbasaltConfig = struct {
    enabled: bool = false,
    effects: []const []const u8 = &.{}, // e.g., ["cas", "smaa"]
    cas_sharpness: f32 = 0.4,
};

// ─── Mod Organizer 2 Configuration ──────────────────────────────────────────────
pub const ModOrganizerConfig = struct {
    enabled: bool = false,
    instance_path: ?[]const u8 = null, // Path to MO2 instance
    portable: bool = true,
    nxm_handler: bool = true, // Handle nxm:// links
};

// ─── Vortex Configuration ───────────────────────────────────────────────────────
pub const VortexConfig = struct {
    enabled: bool = false,
    nxm_handler: bool = true,
};

// ─── VR Configuration ───────────────────────────────────────────────────────────
pub const VrConfig = struct {
    mode: VrMode = .disabled,
    uevr: UevrConfig = .{},
};

pub const VrMode = enum {
    disabled,
    native, // Game has native VR
    uevr, // Use UEVR injection
    flat2vr, // Use Flat2VR
};

pub const UevrConfig = struct {
    enabled: bool = false,
    profile: ?[]const u8 = null,
    inject_delay_ms: u32 = 5000,
};

// ═══════════════════════════════════════════════════════════════════════════════
// CONFIG LOADING / SAVING
// ═══════════════════════════════════════════════════════════════════════════════

/// Get the config directory path
pub fn getConfigDir(allocator: std.mem.Allocator) ![]const u8 {
    // Check STL_CONFIG_DIR environment variable first
    if (std.posix.getenv("STL_CONFIG_DIR")) |dir| {
        return try allocator.dupe(u8, dir);
    }

    // Use XDG_CONFIG_HOME or default to ~/.config
    const config_home = std.posix.getenv("XDG_CONFIG_HOME") orelse blk: {
        const home = std.posix.getenv("HOME") orelse return error.NoHomeDirectory;
        break :blk try std.fmt.allocPrint(allocator, "{s}/.config", .{home});
    };

    return try std.fmt.allocPrint(allocator, "{s}/stl-next", .{config_home});
}

/// Load game-specific configuration
pub fn loadGameConfig(allocator: std.mem.Allocator, app_id: u32) !GameConfig {
    const config_dir = try getConfigDir(allocator);
    defer allocator.free(config_dir);

    const config_path = try std.fmt.allocPrint(
        allocator,
        "{s}/games/{d}.json",
        .{ config_dir, app_id },
    );
    defer allocator.free(config_path);

    const file = try std.fs.openFileAbsolute(config_path, .{});
    defer file.close();

    const stat = try file.stat();
    const content = try allocator.alloc(u8, stat.size);
    defer allocator.free(content);
    const bytes_read = try file.readAll(content);

    // Parse JSON (simplified - would use std.json in full implementation)
    // For now, just verify we read something
    if (bytes_read == 0) {
        return GameConfig.defaults(app_id);
    }

    // TODO: Implement actual JSON parsing
    return GameConfig.defaults(app_id);
}

/// Save game-specific configuration
pub fn saveGameConfig(allocator: std.mem.Allocator, game_config: *const GameConfig) !void {
    const config_dir = try getConfigDir(allocator);
    defer allocator.free(config_dir);

    // Ensure directory exists
    const games_dir = try std.fmt.allocPrint(allocator, "{s}/games", .{config_dir});
    defer allocator.free(games_dir);

    std.fs.makeDirAbsolute(games_dir) catch |err| {
        if (err != error.PathAlreadyExists) return err;
    };

    const config_path = try std.fmt.allocPrint(
        allocator,
        "{s}/{d}.json",
        .{ games_dir, game_config.app_id },
    );
    defer allocator.free(config_path);

    const file = try std.fs.createFileAbsolute(config_path, .{});
    defer file.close();

    // Write JSON (simplified)
    try file.writer().print(
        \\{{
        \\  "app_id": {d},
        \\  "mangohud": {{"enabled": {}}},
        \\  "gamemode": {}
        \\}}
        \\
    , .{
        game_config.app_id,
        game_config.mangohud.enabled,
        game_config.gamemode,
    });
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "mangohud config generation" {
    var config = MangohudConfig{
        .enabled = true,
        .show_fps = true,
        .show_cpu = true,
        .show_gpu = true,
    };

    const result = try config.generateConfig(std.testing.allocator);
    defer std.testing.allocator.free(result);

    try std.testing.expect(std.mem.indexOf(u8, result, "fps") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "cpu_stats") != null);
}

// TODO: Fix memory management in this test
// test "gamescope args building" {
//     const config = GamescopeConfig{
//         .enabled = true,
//         .width = 1920,
//         .height = 1080,
//         .fullscreen = true,
//         .fsr = true,
//     };
// 
//     const args = try config.buildArgs(std.testing.allocator);
//     defer {
//         for (args) |arg| {
//             std.testing.allocator.free(arg);
//         }
//         std.testing.allocator.free(args);
//     }
// 
//     try std.testing.expectEqualStrings("gamescope", args[0]);
// }

